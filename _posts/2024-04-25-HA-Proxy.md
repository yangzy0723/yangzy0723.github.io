---
layout: mypost
title: HA-Proxy
categories: [杂七杂八]
---

## 一、HA-Proxy概述

HA-Proxy是一款高性能的负载均衡软件。因为其专注于负载均衡这一些事情，因此与Nginx比起来在负载均衡这件事情上做得更好，更专业。

## 二、基础介绍

[官方网站](https://www.haproxy.org/)

HA-Proxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HA-Proxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HA-Proxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上。

HA-Proxy实现了一种事件驱动，单一进程模型，此模型支持非常大的并发连接数。多进程或多线程模型受内存限制、系统调度器限制以及无处不在的锁限制，很少能处理数千并发连接。

## 三、HA-Proxy的特点

HA-Proxy作为目前流行的负载均衡软件，必须有其出色的一面。下面介绍一下HA-Proxy相对LVS，Nginx等负载均衡软件的优点。

- 支持tcp/http两种协议层的负载均衡，使得其负载均衡功能非常丰富
- 支持8种左右的负载均衡算法，尤其是在http模式时，有许多非常实在的负载均衡算法，适用各种需求
- 性能非常优秀，基于单进程处理模式（和Nginx类似）让其性能卓越
- 拥有一个功能出色的监控页面，实时了解系统的当前状况
- 功能强大的ACL (Access Control List 访问控制列表)支持，给用户极大的方便

## 四、HA-Proxy的核心功能和关键特性

### 4.1 HA-Proxy的核心功能

| 策略       | 作用                           |
|------------|--------------------------------|
| roundrobin | 表示简单的轮询                  |
| static-rr  | 表示根据权重                    |
| leastconn  | 表示最少连接者先处理            |
| source     | 表示根据请求源IP                |
| uri        | 表示根据请求的URI,做cdn需使用   |
| url_param  | 表示根据请求的URl参数           |
| hdr(name)  | 表示根据HTTP请求头来锁定每一次HTTP请求 |
| rdp-cookie(name) | 表示根据cookie(name)来锁定并哈希每一次TCP请求 |

- **负载均衡：** L4和L7两种模式，支持RR、静态RR、LC、IP Hash、URI Hash、URL_PARAM Hash、HTTP_HEADER Hash等丰富的负载均衡算法
- **支持TCP和HTTP两种健康检查模式**
- **SSL：** HA-Proxy可以解析HTTPS协议，并能够将请求解密为HTTP后向后端传输
- **HTTP请求重写与重定向**
- **监控与统计：** HA-Proxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HA-Proxy的状态

从核心功能上看，HA-Proxy实现的功能类似于Nginx的L4、L7反向代理。

### 4.2 HA-Proxy关键特性

#### 性能

- 采用单线程、事件驱动、非阻塞模型，减少上下文切换的消耗，能在1ms内处理数百个请求。并且每个会话只占用数KB的内存
- 大量精细的性能优化，如O(1)复杂度的事件检查器、延迟更新技术、Single-buffereing、Zero-copy forwarding等等，这些技术使得HA-Proxy在中等负载下只占用极低的CPU资源
- HA-Proxy大量利用操作系统本身的功能特性，使得其在处理请求时能发挥极高的性能，通常情况下，HA-Proxy自身只占用15%的处理时间，剩余的85%都是在系统内核层完成的
- HA-Proxy作者在8年前（2009）年使用1.4版本进行了一次测试，单个HA-Proxy进程的处理能力突破了10万请求/秒，并轻松占满了10Gbps的网络带宽

#### 稳定性

- 作为建议以单进程模式运行的程序，HA-Proxy对稳定性的要求是十分严苛的。按照作者的说法，HA-Proxy在13年间从未出现过一个会导致其崩溃的BUG，HA-Proxy一旦成功启动，除非操作系统或硬件故障，否则就不会崩溃（我觉得可能多少还是有夸大的成分）
- 在上文中提到过，HA-Proxy的大部分工作都是在操作系统内核完成的，所以HA-Proxy的稳定性主要依赖于操作系统，作者建议使用2.6或3.x的Linux内核，对sysctls参数进行精细的优化，并且确保主机有足够的内存。这样HA-Proxy就能够持续满负载稳定运行数年之久

## 五、负载均衡的类型

### 5.1 无负载均衡

![](1.png)

- 单点故障
- 如果许多用户试图同时访问您的服务器并且无法处理负载，他们可能会遇到缓慢的体验，或者可能根本无法连接

### 5.2 4层负载均衡

![](2.png)

- 工作在OSI模型的第四层，即传输层，主要处理TCP/UDP协议
- 基于IP地址和端口号进行负载均衡决策，不关心传输的数据内容
- 它的速度非常快，因为它不需要解析应用层的数据，只需要根据IP地址和端口进行路由
- 4层负载均衡器可以处理大量的并发连接，适合于需要高性能和高吞吐量的场景

### 5.3 7层负载均衡

![](3.png)

- 工作在OSI模型的第七层，即应用层，可以处理HTTP、HTTPS等应用层协议
- 基于应用层的数据内容进行负载均衡决策，如URL、Cookies、HTTP头部等
- 由于需要解析应用层的数据，7层负载均衡的处理速度通常比4层慢，但提供了更灵活的流量管理功能
- 7层负载均衡适合于需要内容感知和复杂路由的场景，如Web应用的负载均衡、API网关等

总结来说，4层负载均衡更注重性能和速度，适合于大量并发连接的场景；而7层负载均衡更注重灵活性和内容感知，适合于需要精细流量控制的场景。

## 六、HA-Proxy集群

尽管HA-Proxy非常稳定，但仍然无法规避操作系统故障、主机硬件故障、网络故障甚至断电带来的风险。所以必须对HA-Proxy实施高可用方案。可以利用Keepalived实现HA-Proxy热备方案。即两台主机上的两个HA-Proxy实例同时在线，其中权重较高的实例为MASTER，MASTER出现问题时，另一台实例自动接管所有流量。

在两台HA-Proxy的主机上分别运行着一个Keepalived实例，这两个Keepalived争抢同一个虚IP地址，两个HA-Proxy也尝试去绑定这同一个虚IP地址上的端口。显然，同时只能有一个Keepalived抢到这个虚IP，抢到了这个虚IP的Keepalived主机上的HA-Proxy便是当前的MASTER。Keepalived内部维护一个权重值，权重值最高的Keepalived实例能够抢到虚IP。同时Keepalived会定期check本主机上的HA-Proxy状态，状态OK时权重值增加。